<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <tool name="file loader" label="File Loader" icon="hicon:/SVGIcons.index?BUTTONS_auto_save.svg">
    <script scriptType="python"><![CDATA[#coding = utf-8
import hou
import os
tar_dir = hou.ui.selectFile(title="Select obj File Folder",file_type = hou.fileType.Directory)
tar_dir = tar_dir.replace("\\","/")
filelist = os.listdir(tar_dir)
pre_boundx=0
if tar_dir:
    root_node = hou.node("/obj").createNode("geo","Loader")
    print tar_dir
    m_node = root_node.createNode("merge")
    for file in filelist:
        print(file)
        filename = os.path.splitext(file)[0]
    # create file node
        filenode = root_node.createNode("file",filename)
    # add path to file parm
        filepath = os.path.join(tar_dir,file)
        filenode.parm("file").set(filepath)
        
    # add transfrom node
        current_boundx = abs(filenode.geometry().boundingBox().minvec()[0])
        current_boundx_len = filenode.geometry().boundingBox().maxvec()[0]
        current_posx = current_boundx + pre_boundx +10
        if pre_boundx==0:
            pre_boundx = current_boundx_len
            m_node.setNextInput(filenode)
            continue 
        trans = root_node.createNode("xform","%s_trans"%filename)
        trans.parm("tx").set(current_posx)     
        trans.setFirstInput(filenode)
    #after loop merge together
        m_node.setNextInput(trans)
        pre_boundx = current_posx+current_boundx_len

    m_node.moveToGoodPosition()
root_node.layoutChildren()
    
]]></script>
  </tool>

  <tool name="otl_update" label="Otl_sort_record" icon="hicon:/SVGIcons.index?BUTTONS_auto.svg">
    <script scriptType="python"><![CDATA[#coding = utf-8
import os
import sys
import shutil
import time
import json

otl_root = r"C:\Users\Administrator\Documents\houdini17.0\otls"
version_root = r"C:\Users\Administrator\Documents\houdini17.0\otls\temp_version"
file_dic = {}

def version_dic(version_root):
    """
    :param version_root:
    :return:
    """
    file_dic = {}
    current_version_filelist = os.listdir(version_root)
    for version_file in sorted(current_version_filelist):
        version_file_fullpath = os.path.join(version_root,version_file)
        version_shortfilename = os.path.splitext(version_file)[0].split("_v")[0]
        file_mtime = os.path.getmtime(version_file_fullpath)
        try:
            file_version = os.path.splitext(version_file)[0].split("_v")[1]
        except:
            file_version = 1
        print(version_shortfilename)
        print(file_version)
        print(file_mtime)
        print(file_dic.get(version_shortfilename),int(file_version))
        if not file_dic.get(version_shortfilename) or file_dic.get(version_shortfilename).get("version")<int(file_version):
            file_dic[version_shortfilename]={}
            file_dic[version_shortfilename]["version"] = int(file_version)
            file_dic[version_shortfilename]["mtime"] = file_mtime
    print file_dic
    return file_dic

def check_NoVersionFiles(noversion_path,version_dic,tar_dir):
    update_record = {}
    #no_version_files
    for no_version_file in os.listdir(noversion_path):
        nv_file_full_path = os.path.join(noversion_path,no_version_file)
        if os.path.isdir(nv_file_full_path):
            continue
        print(nv_file_full_path)
        file_mtime = os.path.getmtime(nv_file_full_path)
        print(time.ctime(file_mtime))
        no_version_filename =os.path.splitext(no_version_file)[0]
        #check the dic
        if not version_dic.get(no_version_filename):
            copy_verison(nv_file_full_path,tar_dir,1)
            update_record[no_version_filename]={"version":1,"mtime":file_mtime}
        else:
            #get modify time and compare with the version file
            record_mtime = version_dic.get(no_version_filename).get("mtime")
            if file_mtime>record_mtime:
                verison = version_dic.get(no_version_filename).get("version")+1
                copy_verison(nv_file_full_path, tar_dir, verison)
                update_record[no_version_filename] = {"version": verison, "mtime": file_mtime}
    return update_record

def copy_verison(org_filepath,tar_dir,version):
    org_file = os.path.basename(org_filepath)
    org_filename = os.path.splitext(org_file)[0]
    org_fileext = os.path.splitext(org_file)[1]
    target_file_path = os.path.join(tar_dir,"%s_v%02d%s"%(org_filename,version,org_fileext))
    print(org_filepath)
    print(target_file_path)
    shutil.copy(org_filepath,target_file_path)



file_dic = version_dic(version_root)
new_file_dic = check_NoVersionFiles(otl_root,file_dic,version_root)


if not os.path.exists(os.path.join(r"D:/hda_log",time.strftime("%Y%m%d"))):
    os.mkdir(os.path.join(r"D:/hda_log",time.strftime("%Y%m%d")))

update_path = os.path.join(r"D:/hda_log",time.strftime("%Y%m%d"),"%s_%s.json"%("new_otl",time.strftime("%Y%m%d_%H%M")))
with open(update_path,"w+") as outfile:
    json.dump(new_file_dic,outfile)











]]></script>
  </tool>

  <tool name="curve_s" label="Curve_save" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import json
import os

def saveCurve(*args, **kwargs):
    curve_dic = {}
    node = hou.selectedNodes()[0]
    node_name = node.name()
    if os.path.exists(r"D:/%s"%node_name):
        for file_del in os.listdir("D:/%s"%node_name):
            os.remove(os.path.join(r"D:/%s"%node_name,file_del))
    else:
        os.mkdir(r"D:\%s"%node_name)    
    # get curve nodes
    curve_node_list = []
    for pend_node in node.children():
        print(pend_node)
        if pend_node.type().name() == "curve":
            curve_node_list.append(pend_node)
    if not curve_node_list:
        return
    #save every node and every parm
    for curve_node in curve_node_list:
        name = curve_node.name()
        for parm in curve_node.parms():
            curve_dic[parm.name()]=parm.eval()
            print parm.name()
            print parm.eval()
        test_path = r"D:\%s\%s.json"%(node_name,name)
        with open(test_path, "w+") as outfile:
            json.dump(curve_dic, outfile)

    # curve_node = node.node("Target_node")
    # 
    # # get point info
    # curve_points = curve_node.parm("coords").eval().strip().replace(", ", ",").split(" ")
    # 
    # point_count = 0
    # point_dic = {}
    # for point in curve_points:
    #     point_x = point.split(",")[0]
    #     point_y = point.split(",")[1]
    #     point_z = point.split(",")[2]
    #     point_dic[point_count] = {"pos_x": point_x, "pos_y": point_y, "pos_z": point_z}
    #     point_count += 1

    
        
saveCurve()       ]]></script>
  </tool>

  <tool name="curve_load" label="Curve_load" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import json
import os

def loadCurve(*args, **kwargs):
    node = hou.selectedNodes()[0]
    node_name = node.name()
    test_path = r"D:\%s"%node_name
    if not os.path.exists(test_path):
        return
    # delete all child node
    for node in node.children():
        node.destroy()

    #read data
    for curve_data in os.listdir(test_path):
        full_data_path = os.path.join(test_path,curve_data)
        curve_name = os.path.splitext(curve_data)[0]

        #create curve node
        target_node = node.createNode("curve",curve_name)

        parm_dic = {}
        with open(full_data_path, "r") as outfile:
            all_info = outfile.read()
            parm_dic = json.loads(all_info)

        #add width parm to interface
        current_tmpparm = target_node.parmTemplateGroup()
        current_tmpparm.append(hou.FloatParmTemplate("width","Width",1))
        target_node.setParmTemplateGroup(current_tmpparm)
        target_node.setParms(parm_dic)
    print("Loaded!")

loadCurve()]]></script>
  </tool>

  <tool name="ui_test" label="ui_test" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[#coding = utf-8
import sys
from PySide2 import QtGui,QtWidgets,QtCore


class input_Window(QtWidgets.QFrame):
    def __init__(self):
        # tool setting
        super(input_Window, self).__init__(parent=None)
        self.setParent(hou.ui.mainQtWindow(),QtCore.Qt.Window)
        self.setWindowTitle("get input value")
        # ui setting
        # hda name
        hda_name_layout = QtWidgets.QHBoxLayout()
        hda_name_label = QtWidgets.QLabel(r"Hdaåç§°:")
        self.hda_name_input = QtWidgets.QLineEdit(r"Hdaåç§°")
        hda_name_layout.addWidget(hda_name_label)
        hda_name_layout.addWidget(self.hda_name_input)

        # hda path
        hda_path_layout = QtWidgets.QHBoxLayout()
        hda_path_label = QtWidgets.QLabel(r"Hdaä¿å­è·¯å¾:")
        self.hda_path_input = QtWidgets.QLineEdit("$HIP")
        hda_path_layout.addWidget(hda_path_label)
        hda_path_layout.addWidget(self.hda_path_input)

        send_btn = QtWidgets.QPushButton(r"çæ")
        layout = QtWidgets.QVBoxLayout()
        layout.addLayout(hda_name_layout)
        layout.addLayout(hda_path_layout)
        layout.addWidget(send_btn)
        self.setLayout(layout)
        # connect signal
        send_btn.clicked.connect(self.get_input_value)

    def get_input_value(self):
        hda_name = self.hda_name_input.text()
        hda_path = self.hda_path_input.text()
        print(hda_name,hda_path)
        self.close()
         
a = input_Window()
#a.setParent(hou.ui.mainQtWindow(),QtCore.Qt.Window)
a.show()

]]></script>
  </tool>

  <tool name="ui" label="ui" icon="hicon:/SVGIcons.index?VIEW_visualization_slice.svg">
    <script scriptType="python"><![CDATA[from Td import display_ui as di
reload(di)
di.run()]]></script>
  </tool>

  <tool name="geo_info" label="geo_info" icon="hicon:/SVGIcons.index?BUTTONS_move_to_right.svg">
    <script scriptType="python"><![CDATA[from Td import geo_info as gi
reload(gi)
gi.show_window()]]></script>
  </tool>

  <toolshelf name="test" label="test">
    <memberTool name="tool_1"/>
  </toolshelf>

  <tool name="tool_1" label="New Tool" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import os
ProjectPath = "E:/REF/Art" #æ³¨æï¼è¿ä¸ªè·¯å¾åºè¯¥æ¯ä½ é¡¹ç®çArtè·¯å¾ï¼è¯·æ´æ¢ï¼
for fpathe,dirs,fs in os.walk(ProjectPath+"/HouLand/OperatorHDAs"):
    for f in fs:
        HDAPath = os.path.join(fpathe,f)
        if(HDAPath.endswith(".hda")):
            hou.hda.installFile(HDAPath)
for fpathe,dirs,fs in os.walk(ProjectPath+"/HouLand/PublicDataHDAs"):
    for f in fs:
        HDAPath = os.path.join(fpathe,f)
        if(HDAPath.endswith(".hda")):
            hou.hda.installFile(HDAPath)
for fpathe,dirs,fs in os.walk(ProjectPath+"/HouLand/LandscapeHDAs"):
    for f in fs:
        HDAPath = os.path.join(fpathe,f)
        if(HDAPath.endswith(".hda")):
            hou.hda.installFile(HDAPath)]]></script>
  </tool>

  <tool name="update_py" label="update_py" icon="hicon:/SVGIcons.index?PLAYBAR_set_key.svg">
    <script scriptType="python"><![CDATA[#coding = utf-8
import hou
#get hda nodes
hda_nodes = hou.selectedNodes()

#get hda code
python_node = hou.node(hou.ui.selectNode())
python_code = python_node.parm("python").eval()

for hda_node in hda_nodes:
    hda_path = hda_node.type().definition().libraryFilePath()
    hda = hda_node.type().definition()

    python_module = hda.sections()["PythonModule"]
    python_module.setContents(python_code)
    hda.save(hda_path)
]]></script>
  </tool>

  <tool name="tool_2" label="editall" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
def unlockChildren(node):
    for child_node in node.children():
        child_node.allowEditingOfContents(1)
        try:
            unlockChildren(child_node)
        except:
            continue
node = hou.selectedNodes()[0]
node.allowEditingOfContents(1)
unlockChildren(node)]]></script>
  </tool>

  <tool name="lockAll" label="lockAll" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
def lockChildren(node):
    for child_node in node.children():
        child_node.matchCurrentDefinition(0)
        try:
            lockChildren(child_node)
        except:
            continue
node = hou.selectedNodes()[0]
lockChildren(node)
node.matchCurrentDefinition(0)]]></script>
  </tool>

  <tool name="batch_addparm" label="batch_addparm" icon="hicon:/SVGIcons.index?BUTTONS_add.svg">
    <script scriptType="python"><![CDATA[from Td import batch_addparm as bap
reload(bap)
bap.run()]]></script>
  </tool>

  <tool name="rCurve" label="rcurve" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[#coding = utf-8
import hou
import json
import os
from collections import OrderedDict

tar_file = hou.ui.selectFile(title="Select json File")
print(tar_file)
print(os.path.splitext(tar_file))
if os.path.splitext(tar_file)[-1]!=".json":
    hou.ui.displayMessage("select json file!")
else:
    with open(tar_file, "r") as outfile:
        all_info = outfile.read()
        parm_dic = json.loads(all_info, object_pairs_hook=OrderedDict)
    curve_coords = parm_dic.get("coords").get("value")
    new_coords = ""
    for point in curve_coords.split(" "):
        if new_coords:
            new_coords = point + " " +new_coords
        else:
            new_coords = point
    parm_dic["coords"]["value"] = new_coords
    print(new_coords)
    with open(tar_file, "w+") as outfile:
        json.dump(parm_dic, outfile)
    print("Save!!!")]]></script>
  </tool>

  <tool name="appendNode" label="appendNode" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[nodes = hou.selectedNodes()
if nodes:
    parent = nodes[0].parent()
    for node in nodes:
        print(node)
        xf = parent.createNode("xform")
        xf.setInput(0,node)
        xf.moveToGoodPosition()]]></script>
  </tool>

  <tool name="PrintKwargs" label="PrintKwargs" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
def PrintKwargs(*kwargs):
    print kwargs
    
PrintKwargs(kwargs)]]></script>
  </tool>

  <tool name="waterinit" label="waterinit" icon="hicon:/SVGIcons.index?BUTTONS_add_constraints.svg">
    <script scriptType="python"><![CDATA[import hou
import os,sys
import hrpyc
import cProfile
import toolutils
import soptoolutils
import itertools

data_path = r"E:\REF\Art\HouLand\LandscapeHDAs"

obstacles = [file for file in os.listdir(data_path) if "Obstacle" in file]
print(obstacles)
tileDict = {tile:"%s_cache.hda"%tile.replace("Obstacle_","").replace(".bgeo","") for tile in obstacles}
print(tileDict)

node = hou.selectedNodes()[0]
print(node)
for obstacleCache,hda in tileDict.items():
    #create hda
    hda = hda.split(".")[0]
    #HDAPath = os.path.join(data_path,hda)
    #hou.hda.installFile(HDAPath)
    node.createNode(hda)
    #create Cache file
    filenode = node.createNode("file")
    obstacleCachePath = os.path.join(data_path,obstacleCache)
    filenode.parm("file").set(obstacleCachePath)
    #print obstacleCache


]]></script>
  </tool>

  <tool name="RemoteCoding" label="RemoteCoding" icon="hicon:/SVGIcons.index?VOP_xor.svg">
    <script scriptType="python"><![CDATA[import hrpyc
hrpyc.start_server()]]></script>
  </tool>

  <tool name="BigWorldCache" label="BigWorldCache" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import os,sys,socket
import hrpyc
import cProfile
import toolutils
import soptoolutils
import itertools
import hou
#tile list
bgeo_path = r"G:\REF\art_dev\Art\HouLand\LandscapeHDAs"
files = [tile for tile in os.listdir(bgeo_path) if tile.endswith("bgeo") and tile.startswith("Tile") and not "Lake" in tile and not "River" in tile or tile.startswith("Seam")]
tilefiles = [tile for tile in files if tile.endswith("bgeo")]
seamtiles = [tile for tile in tilefiles if tile.startswith("Seamed")]
# print(seamtiles)

for seam in seamtiles:
    tilename = seam[-9:-5]
    tilefiles = [tile for tile in tilefiles if not tilename in tile]

print(tilefiles)
print(len(tilefiles))
print(len(seamtiles))
subnode = hou.selectedNodes()[0]
for tile in tilefiles:
    tile_path = os.path.normpath(os.path.join(bgeo_path,tile))
    file_node = subnode.createNode("file")
    file_node.parm("file").set(tile_path)
for tile in seamtiles:
    tile_path = os.path.normpath(os.path.join(bgeo_path, tile))
    file_node = subnode.createNode("file")
    file_node.parm("file").set(tile_path)]]></script>
  </tool>
</shelfDocument>
